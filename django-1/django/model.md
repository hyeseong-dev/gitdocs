---
description: 장고의 핵심 기능 - Model
---

# Model

## 모델이란? 

 모델이란 테이블을 정의하는 장고의 클래스를 의미하며, models.py 파일에 테이블 관련 사항들을 정의합니다. models.py 파일에는 테이블을 정의하는 것이 기본이지만, 그 외에도 **관련 변수 및 메소드를 추가적으로 정의**할 수 있습니다. 이는 **ORM 방식**에 기반해 **테이블을 클래스로 정의**하고 있어 **클래스의 특징인 변수와 메소드를 가질 수 있기 때문**입니다. **ORM방식의 장점**입니다.

## 1. 모델의 정의 

테이블을 class로 처리하는 ORM기법의 특징에 따라 테이블을 정의하는 모델 클래스는 속성과 메소드를 갖게 됩니다. 테이블 컬럼은 모델 클래스의 속성으로 정의하고, 테이블에는 메소드가 없지만 모델 클래스에는 메소드를 정의 할 수 있습니다. 물론 테이블에 관련된 메소드들입니다. 이렇게 함으로써 테이블에 관련된 데이터와 행위를 모두 모델 클래스 한 곳에서 정의할 수 있는 장점이 생깁니다. 즉 테이블의 컬럼은 모델 클래스의 속성으로 정의하고 테이블과 관련된 함수는 모델 클래스의 메소드로 정의하는 것입니다. 

![](../../.gitbook/assets/image%20%28576%29.png)

ORM 기법의 특징에 따라 테이블의 컬럼은 모데 클래스의 속성으로 정의합니다. 장고에서는 **테이블의 컬럼**을 **테이블의 필드** 또는 **모델의 필드**라고 하는데, 결국 **모델의 필드들은 모델 클래스의 속성으로 정의**되고 모델 클레스의 속성들은 테이블 컬럼으로 1:1 매핑 됩니다. 

따라서 모델 클래스의 속성 중에서 **모델 필드는 가장 중요한 속성이며 필수**이기도 합니다.   
즉 테이블의 정의에서 컬럼이 필수인 것과 같은 이치입니다. 컬럼으로 테이블을 정의하듯이 모델 필드로 모델 래스를 정의하는 것입니다. 

위의 Album 모델은 objects 속성을 포함해서 **4개의 모델 속성을 정의**하고 있으며, 이 중 3개의 속성은 테이블 컬럼에 해당하는 모델 필드들입니다. 모델 클래스에서 필드를 정의하기 위해서는 항상 필드명,필드 타입과 필드 옵션을 지정해줘야 합니다. 

각 필드는 용도에 따라 적절한 타입을 지정해야 하는데, 필드 타입의 역할은 다음과 같습니다.  

* 테이블의 컬럼 타입을 지정합니다. 예를 들어 CharField 필드 타입은 커럼의 VARCHAR 타입으로 변한됨.
* 폼으로 랜더링되는 경우 html 위젯을 지정합니다. 예를 들어 CharField 필드 타입은 폼으로 사용될때 &lt;input type='text'&gt;ㅗ씌 태그로 변환되고 및 그에 상응하는 위젯을 지정합니다. 
* 필드 또는 폼에 대한 유효성 검사 시 최소 기준이 됩니다. 



## 2. 모델 메소드 

 모델 클래스에는 메소드를 정의 할 수 있습니다. 

여기서 주의할점은 **클래스 메소드**와 **객체 메드**를 구분하는 것입니다.

#### 클래스 메소드 --  테이블 레벨에서 동작하는 메소드

#### 객체 메소드 -- 레코드 레벨에서 동작하는 메소드 

> **장고에서는 클래스 메소드를 사용하지 않고 객체 메소드만 사용합니다.   
> 즉, 모델 클래스에 정의하는 메소드는 모두 객체 메소드이고 항상 self 인자를 갖고 있으며, 이 메소드들은 호출하면 테이블 단위가 아니라 레코드 단위에만 영향을 미칩니다.**

> **그럼 테이블의 모든 레코드 수를 카운트하는 것처럼, 테이블 레벨의 동작은 어떻게 해야 할까요?  
> 장고는 클래스 메소드를 사용하는 대신, 별도의 Manager 클래스를 정의하고 Manager 클래스를 정의하고 Manager 클래스의 메소드를 통해서 테이블에 대한 CRUD 동작을 수행합니다.**

#### **모델 메소드 몇가지** 

#### **1. \_\_str\_\_\(\) :  이 메소드를 어버라이딩 하지 않으면 장고의 디폴트 \_\_str\_\_\(\) 메소드에 의해 객체의 문자열이 표현됩니다. 디포트 문자열\(예: Bookmark object\)은 보는 사람이 이해하기 어렵습니다.  그래서 이해하기 쉬운 문자 표현으로 대부분 바꿔서 설정해줘요.** 

\*\*\*\*

**2. get\_absolute\_url\(\) : 자신이 정의된 객체를 지칭하는 URL을 반환함.   
URLconf에서 DetailView 제네릭 뷰를 사용하는 경우가 좋은 예입니다. DetailView는 특정 객체에 대한 상세 정보를 보여주는 제네릭 뷰이므로, DetailView와 매핑된 URL을 get\_absolute\_url\(\)메소드를 사용해 구 할 수 있기 때문입니다. 특정 객체의 URL을 구하는 기능은 코드의 여러 곳에서 필요하므로, 아래 메소드는 항상 정의해주는 게 좋습니다.** 

2.1 이 메소드 template에서도 자주 사용하는데요. 이 메소드의 가장 큰 장점은 URL을 표현하기 위해 하드 코딩을 하지 않아도 되요. 

필드 타입이 DateField 또는 DataTimeField면서 필드 옵션이 null = True가 아닌 경우에는 다음 메소드를 사용할 수 있습니다. FOO는 필드명을 의미하고, 필요하면 키워드 인자를 사전 형식으로 전달 할수 있어요. 이 함수는 FOO필드 기준으로 다음 객체를 반환해요. 다음 객체가 없는 경우는 DoesNotExist Exception이 발생해요. 

> **get\_next\_by\_FOO\(\*\*kwargs\)**

> **get\_previous\_by\_FOO\(\*\*kwargs\)**

\*\*\*\*

\*\*\*\*

> **get\_FOO\_display\(\)**

필드 옵션에 **choice 인자가 있으면, 그 모델 객체는 아래 메소드를 제공해요. FOO는 choices인자를 갖는 필드를 의미해요. 이 메소든 FOO필드의 설명 문자열을 반환합니다.** 

### 2.1 Meta 내부 클래스 속성 

 장공서는 모델 클래스의 필드는 아니지만 모델 클래스에 필요한 항목을 Meta 내부 클래스에서 정의합니다. 즉 필드\(컬럼\)는 모델 클래스의 속성으로, 필드 이외 항목은 Meta 내부 클래스의 속성으로 정의해 모델의 필드 속성과 그 외 속성을 구분하고 있어요. 

#### Ordering

오름 차순과 내림차순 정렬을 정하게 해줘요.   
pub\_date를 기준으로 내림차순 정렬 이후 author 필드를 기준으로 오름차순 정렬을 합니다. 

```text
ordering = ['-pub_date', 'author']
```

#### db\_table

db에 저장되는 테이블 이름을 지정하는데요. 만약 지정하지 않으면 장고는 디폴트로 앱명\_클래스명\(소문자\)를 테이블 이름으로 지정해요. 

```text
db_table = 'tb_post'
```

####  verbose\_name

사용자가 이해하기 쉬운 모델 객체의 alias에요. 이 항목을 지정하지 않으면 장고는 모델 클래스명을 변형해서 디폴트 verbose\_name으로 사용해요. 

예를들어 모델 클래스명이 FavoritePost라면 디폴트 verbose\_named은 favorite post가 되요.   
만약 다르게 하고 싶으면 아래 처럼 해주세요. 

```text
verbose_name = 'my favorite post'
```

####  verbose\_name\_plural 

복수 명칭을 말하는데요 . 별도의 설정을 하지 않으면 디폴트로 verbose\_name + 's'가 사용되요. 



####  장고 메타 항

{% embed url="https://docs.djangoproject.com/en/3.1/ref/models/options/" %}



### 2.2 Manager 속성 

앞에서 모델 속성과Meta 내부 클래스 속성을 구분해, 모델의 필드는 모두 모델 속성으로 정의한다고 했어요. 그런데 모델 속성 중에서 예외적으로 필드, 즉 테이블의 컬럼으로 매핑되지 않는 속성이 있는데 바로 Manager 속성입니다. 

