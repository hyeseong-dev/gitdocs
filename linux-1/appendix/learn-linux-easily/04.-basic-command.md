---
description: 리눅스 파일 명령어
---

# 04. Basic Command

##  되돌아 보며 

나박사 : 쉘은 커널과 사용자 프로그램 사이에서 서로 연결 해주는 인터페이스 역할을 합니다. 

즉, 쉘은 사용자 프로그램으로부터 전달 받은 명령어를 해석하여 커널에 전달해 주고, 커널에서 처리된 결과를 다시 사용자 프로그램에 전달해 주는 역할을 합니다. 이제 쉘에서 사용되는 기본 명령어에 대해서 알아보도록 할까요?

![](../../../.gitbook/assets/image%20%28632%29.png)

##  학습을 시작하기 전에 

![](../../../.gitbook/assets/image%20%28614%29.png)

##  리눅스 명령어에 대한 정보를 얻는 방법

![](../../../.gitbook/assets/image%20%28616%29.png)

###  시스템 관리 명령어 

시스템 관리 명령어는 보통 /sbin과 /usr/sbin 디렉토리에 존재하며, 일반 명령어는 /bin과 /usr/bin 디렉토리에 위치

### 일반 명령어 

일반 명령어는 /bin과 /usr/bin 디렉토리에 위치



일반적으로, /bin 디렉토리와 /usr/bin 디렉토리의 명령어들은 모두 외부 명령어 즉, 유틸리티 프로그램이며, 사용 방법은 내부 명령어와 동일



리눅스에서 명령어의 도움말을 볼 수 있는 대표적인 명령어로 help, man, info 등이 있는데요, 여기서 man과 info는 외부 명령어의 도움말을 확인할 때 사용하는 명령어이며, help는 쉘 내부 명령어의 도움말을 확인할 때 사용하는 명령



![](../../../.gitbook/assets/image%20%28592%29.png)

![](../../../.gitbook/assets/image%20%28630%29.png)



![](../../../.gitbook/assets/image%20%28617%29.png)

![](../../../.gitbook/assets/image%20%28582%29.png)

![](../../../.gitbook/assets/image%20%28603%29.png)

![](../../../.gitbook/assets/image%20%28640%29.png)

나박사 : 먼저 제일 앞에 나온 find는 키워드가 일치한 경우에 나오는 부분이에요. 

그리고 \(1\), \(1p\)라고 하는 것은 man 분류표에 의거 분류된 명령어 매뉴얼의 위치를 나타냅니다. 

즉 \(1\)의 경우는 /usr/share/man/man1 디렉토리에 위치한 명령어 매뉴얼을 나타내고 

\(1p\)의 경우는 /usr/share/man/man1p 디렉토리에 위치한 명령어 매뉴얼을 나타내죠. 그리고 마지막 설명은 표시된 디렉토리에 있는 명령어에 대한 간략한 설명을 보여주는 부분입니다.





> **apropose 키워드**

**요약**

검색어와 관련있는 명령어를 설명과 함께 출력한다.

**경로**

**/usr/bin/apropos**

**사용방법**

**apropos \[검색어\]**

검색어 : 검색하고 싶은 문자열

**설명 및 예제**

apropos는 검색어와 관련 있는 명령어를 whatis DB에서 검색하여 간단한 설명과 함께 출력한다.

whatis는 검색어가 whatis DB의 명령어 리스트와 이름이 동일한 경우만 출력하지만, apropos는 검색어 일부가 명령어나 설명에 포함된 경우까지 모두 출력한다.

예를 들어 리눅스에서 GIMP 등의 그래픽 툴을 사용하지 않고도 비트맵 파일을 jpeg 파일로 변경할 수 있다.

그런데 그 명령어가 생각나지 않을 경우 다음과 같이 입력한다.

```text
# apropos jpeg
```

apropos 명령어에 검색어로 jpeg을 사용하면, 명령어나 요약 설명에 jpeg이라는 단어가 들어있는 모든 명령어를 출력한다.  


우리가 찾는 이미지를 jpeg 파일로 만들어 주는 명령어는 가장 위에 있는 cjpeg 임을 알 수 있따. 또한 반대로 jpeg 파일을 비트맵이나 그 외의 파일오 만드는 djpeg이라는 명령어가 있다는 것도 알 수 있따.

**관련 명령어**

man : -k 옵션을 사용하면, apropos와 같은 기능을 한다.

whatis : whatis DB에서 명령어와 일치하는 요약 내용을 검색하여 출력한다.  
  
출처: [https://gregorio78.tistory.com/254](https://gregorio78.tistory.com/254) \[알아두면 쓸데있는 IT 잡학사전\]





![](../../../.gitbook/assets/image%20%28600%29.png)





##  리눅스 파일 관련 명령어



![](../../../.gitbook/assets/image%20%28586%29.png)

![](../../../.gitbook/assets/image%20%28653%29.png)

#### 

####  1. 스왑메모리 : 실제로 존재하지는 않지만, 메모리의 역할을 하는 하드디스크의 특정 영역 

#### 2. 공유메모리 : 여러개의 프로세서에 의해서 공유되는 주기억 장치 



#### 3. 버퍼 :  빠른 장치와 느린 장치사이에 느린장치간에 작동하는데 있어서,데이터의 손실을 방지하기 위해서 사용하는것이다.이는 D-RAM을 의미

키보드를 들 수가 있습니다. 터미널 상태의 통신을 할때를  
생각해 봅시다. 만약 게시판에서 키보드로 '엔터'키를 눌러 다음 페이지로 넘기면, 바로 다음 페이지로  넘어가지 못하고 1,2초 늦게 화면이 넘어갑니다. 만약 계속 엔터키를 누르고 있다가 손을 떼면, 손을 놨는데도 엔터키가 눌러지면서 한참을 페이지가 넘어가죠. 이것은 모뎀과 서비스 업체의 화면 처리 속도가 키보드 보다 느리기 때문에 키보드 버퍼가 작동한 것입니다  
만약 화면이 처리된 후에만 키보드 데이터를 받아 들이면, 키보드 타이핑 도중에 글자를 잃어버릴 위험이 있습니다. "1234567890"을 빨리 치면 처리를 못해서 "12367890"이 쳐질 수도 있다는 것이  
죠. 그런것을 막기 위해서 키보드는 사용자가 치는 키를 차례차례 받아 두었다가 처리가 되는 데로 계속 내보내는 것입니다.

이 기능을 버퍼라고 합니다.

C같은 언어로 프로그래밍 할때는 이런 기능을 이용하기도 합니다.

사실 캐시도 넓은 의미로는 버퍼에 포함되는 개념이기 때문에 같은  
뜻으로 쓰이기도 합니다.



#### 4. 캐시 :  기본 처리 장치 속에 들어 있는 고속 메모리



![](../../../.gitbook/assets/image%20%28604%29.png)

free 명령어로는 실제 메모리의 전체용량, 실제 메모리 중 유휴 메모리의 량, 실제 메모리 중 사용중인 메모리의 량, 스왑\(swap\)메모리의 량, 커널에서 사용되는 공유메모리와 버퍼의 량, 캐시된 메모리의 량을 알 수 있죠. 

김과장 : free 명령어에 옵션을 사용했을때와 안했을때의 차이점은 뭔가요?? 

나박사 : free 명령어에 옵션을 사용하지 않으면 시스템의 메모리 전체용량과 사용중인 메모리량, 비어있는 메모리량, 스왑\(swap\)메모리 용량과 사용량 등을 확인할 수 있습니다. 

나잘난 : 그런데 출력되는 항목들이 너무 많아 어려운걸요 ?? 박사님 ~ 자세히 알려주세요. 

나박사 : 함께 살펴보죠. swap 메모리의 결정은 서버 설치 시에 설치한 관리자가 결정한 swap 메모리의 용량입니다. swap 메모리는 시스템 사용 중에 실제 메모리가 부족한 경우 swap 메모리로 설정된 디스크의 부분을 메모리로 잡아서 설정되기 때문에 swap 메모리가 많이 사용되고 있다는 것은 시스템의 전체적인 속도가 떨어진다는 것을 의미하며 지속적으로 swap 메모리가 많이 사용되는 경우에는 실제 메모리의 추가를 고려해야 합니다.



![](../../../.gitbook/assets/image%20%28637%29.png)



![](../../../.gitbook/assets/image%20%28588%29.png)

![](../../../.gitbook/assets/image%20%28609%29.png)

![](../../../.gitbook/assets/image%20%28581%29.png)



![](../../../.gitbook/assets/image%20%28601%29.png)

![](../../../.gitbook/assets/image%20%28619%29.png)

나박사 : date 명령어는 운영체제의 날짜와 시간을 확인하거나 설정할 수 있는 명령어에요. 이 명령어는 clock 명령어와 정확한 구분을 할 수 있어야 하는데, **date 명령어는 운영체제 \(리눅스\)의 시간**을 설정하는 명령어라고 한다면 **clock 명령어**는 **서버자체\(하드웨어\)의 시간을 설정**하고 적용하는 명령어죠.

김과장 : 운영체제의 날짜와 시간을 확인한 것 같은데요?

나박사 : 네, **정확한 시스템 시간 설정을 하려면 rdate 명령어와 clock 명령어를 함께 사용**해야 하죠. **date 명령어로 시간을 설정하더라도 새로 부팅하거나 재부팅 하는 경우 서버의 CMOS에서 시간정보를 가져와 사용해요**. 따라서 **CMOS의 시간 정보가 잘못된 경우**에는 **date 명령어로 시간 정보를 맞추어도 재부팅 후**에는 **시간 정보가 틀리게 되기 때문**이죠.



나박사 : clock는 CMOS의 시각을 설정할 수 있는 명령어에요. CMOS의 시각을 가져와 시스템 시각으로 설정할 수도 있으며, 반대로 시스템 운영체제시각을 CMOS의 시각으로 설정할 수도 있죠.

나잘난 : date 명령어와 차이점이 뭐죠 ?

나박사 : date 명령어는 단순히 시스템 즉, 운영체제의 시각을 설정하는 것이며 서버의 시각을 설정할 수는 없어요. 시스템이 부팅될 때에는 CMOS의 시각이 운영체제에 넘겨져서 부팅 시 초기시각으로 설정되죠. 따라서 부팅 시마다 지속적으로 정확한 시각설정이 필요하다면 clock 명령어로 CMOS의 시각을 정확하게 설정해 두어야해요. 김과장 : clock의 옵션에 대해서 알려주세요. 나박사 : CMOS 의 시각을 확인하고자 할 때에는 clock 명령어에 –r 옵션을 사용하죠. –r 옵션은 CMOS의 시각을 확인하게 해줍니다. 그 결과 첫 번째 예에서 보는 바와 같이 CMOS 시각과 시스템의 시각에는 약 2분 정도의 차이가 있다는 것을 알 수 있어요. 나박사 : 리눅스 시스템 시각으로 CMOS 시각을 설정하고자 한다면 –w 옵션을 사용해요. 대부분의 경우에는 리눅스시스템의 시각이 CMOS의 시각보다는 정확하므로 리눅스 시스템의 시각으로 CMOS의 시각을 설정하기 위하여 “clock –w”로 CMOS 시각을 수정했어요.

나박사 : CMOS의 시각으로 리눅스 시스템의 시각을 설정하려면 –s 옵션을 사용하면 되죠. 시각을 설정한 후에 date 명령어로 확인하고 “clock –r”명령어로 CMOS의 시각을 확인한걸 볼수 있을거에요.

나박사 : –a 옵션을 사용하여 CMOS 시각으로 리눅스시스템의 시각을 설정한 후에 다시 CMOS의 시각을 설정할 수도 있죠. 이와 같이 date 명령어는 운영체제\(리눅스, 커널자체\)의 시간을 설정하는 명령어라고 한다면 clock 명령어는 서버자체\(하드웨어\)의 CMOS\(ROM-BIOS\)의 시간을 설정하고 적용하는 명령어랍니다.



![](../../../.gitbook/assets/image%20%28656%29.png)



**CMOS:** cpu,메모리, 하드디스크 등 컴퓨터에 필요한 대부분의 정보를 저장하고 작동하고 제어하는 컴퓨터 관리 프로그램입니다.

![](../../../.gitbook/assets/image%20%28655%29.png)



![](../../../.gitbook/assets/image%20%28654%29.png)

![](../../../.gitbook/assets/image%20%28662%29.png)



![](../../../.gitbook/assets/image%20%28659%29.png)





##  미션 임파서블 

##  지름길 보기 

![](../../../.gitbook/assets/image%20%28661%29.png)

##  탈출하기 

![](../../../.gitbook/assets/image%20%28657%29.png)



![](../../../.gitbook/assets/image%20%28660%29.png)

## 다음 목적지 

## 

